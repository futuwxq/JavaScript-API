## 数据结构
### 1  [堆](./heap/heap.js)  （原地建堆，插入建堆的 2 种方法，堆排序）

满足下面两个条件的就是堆：

+ 堆是一个完全二叉树

+ 堆上的任意节点值都必须大于等于（大顶堆）或小于等于（小顶堆）其左右子节点值

如果堆上的任意节点都大于等于子节点值，则称为 大顶堆

如果堆上的任意节点都小于等于子节点值，则称为 小顶堆

[堆的经典应用：Top K 问题](./数据结构/heap/topk.js)

[堆的经典应用：中位数问题 ，TP 99 问题](./数据结构/heap/tp99.js)
> TP 99 问题：指在一个时间段内（如5分钟），统计某个方法（或接口）每次调用所消耗的时间，并将这些时间按从小到大的顺序进行排序，取第 99% 的那个值作为TP99 值；例如某个接口在 5 分钟内被调用了100次，每次耗时从 1ms 到 100ms之间不等数据，将请求耗时从小到大排列，TP99 就是取第 100*0.99 = 99 次请求耗时 ，类似地 TP50、TP90，TP99越小，说明这个接口的性能越好

堆的应用

js 里面引用数据类型存储在堆中。 垃圾回收机制等等

### 2 链表
+  [单链表](./linkList/list.js) 
+  [循环链表](./linkList/circularLinkedList.js) 
应用：[约瑟夫环](./linkList/约瑟夫环.js) 
### 3 并查集

### 4 字典树

###  排序算法
时间复杂度为 $o(n^2)$

时间复杂度为 $o(nlogn)$
 +  [堆排序](./排序算法/heapSort.js) 
 +  [归并](./排序算法/merge.js) 
 +  [快排](./排序算法/quick_sort.js)

 时间复杂度为 $o(n)$
 +  基数排序
 +  桶排序
